## 字符串匹配算法

- 母串S`a e c a e a e c a e d` 

- 模式串T`a e c a e d `

  ## 暴力匹配算法

  - 不会漏掉答案
  - 优化（匹配部分　根据情况判断）
    - 当模式串匹配到第６位失配时，模式串向后跳动３位继续匹配　并且我们知道前两位一定是匹配成功的
    - 优化方案 == > 用模式串的信息对匹配操作做一个加速；`O(n*m)`

  ## KMP算法

  - 母串指针不会向前动，只会不动或者向后
  - **第n位失配，向后跳的位置和已经确定匹配的和一定是`n - 1`**
  - **生成next数组的过程　是子串自我匹配的过程** next数组记录的是以当前这个字符作为结尾**公共子串**的长度
  - 母串的指针要不不动，要不向前走，不会回退；`KMP`生成`next`数组的过程，实际上是模式串的自我匹配过程【递归过程】。
  - 最优`O(n+m)`，最差`O(n*m)`，平均`O(n+m)`

  

  ## SUNDAY算法

  - 最快时间复杂度O（n/ｍ）
  - 找在一篇文章中　单词最后一次出现的位置
  - 用于在一篇文章中找一个单词最快。
  - 最优`O(n/m)`，最差`O(n*m)`，平均`O(n+m)`

## SHIFT-AND算法

- 用二进制记录出现的位置（倒着写的　低位在前，高位在后）

- `p = (p << 1 | 1) & d[s[i]]` 

- `p & (1 << (n - 1)) ?= 1`

- `& `之前代表有可能匹配哪几种？？

- ｐ就是NFA模型的思想简化版

- 一旦一个模式串整理成状态码之后，就跟模式串原本的样子彻底脱离关系，就是二进制的运算了　

- 模式串被整理成状态码之后，之后的匹配过程与模式串就没关系了，只是进行一些二进制的运算。

- 最优`O(n*m/K)`，

  最差`O(n*m/K)`，平均`O(n*m/K)`

## 字典树(Trie 单词查找树)

- 作用：单词查找　字符串排序
- 每条边代表一个字母　根所代表的全集代表字典树的全部
- 树中的节点代表集合，边代表关系根代表全集；字典树常用于单词查找和字符串排序
- 字典树中的字母不是标记在节点上的，是标记在关系上的，边代表了一个字母
- 字典树的红色节点代表此集合中有以此前缀为单词的词（这个节点中有元素独立成词）
- 字典序用作排序时的时间复杂度为O(n);比基于比较的排序快很多；如果想用作数字比较，要对数字进行特殊处理（将位数对齐，不然会出现问题，字符串比较中９> 100）

## 双数组字典树

已知：一个数组可以用来表示一个完全二叉树/堆

- **学习重点要放在如何建立父节点和子节点之间的坐标关系**
- 在父节点相应的位置记录一个base值（额外的值）用base值加上？？？得到相关子节点的地址
- base数组让父节点找到子节点，check数组记录子节点的父节点坐标地址（父节点可能有多个子节点但是子节点只有唯一的父节点），独立成词时将相关的flag改成负数
- 0号位是不用的（方便运算）
- 字典树不能拿给其他机器用（因为字典树是跟地址强相关的），双数组字典树可以

## AC自动机

- 多模匹配可以用AC自动机来优化
- fail指针（等价匹配指针）
- 先建立字典树->建立失败指针->
- 队列：树的层序遍历
- 栈：树的深度遍历

fail指针建立方法

- 逐层建立

- （递归）深度遍历建立

  

  

  减少编码长度　哈夫曼编码　---  插入到

  二叉字典树＋哈夫曼编码

## 森林与并查集

- 并查集解决的本质性问题：(没有方向的)连通性判断的问题

### **连通性问题:**

#### 1. QUICK-FIND算法

基于染色思想，一开始所有点的颜色不同；连接两个点的操作可以看成将**一种颜色**的点染成**另一种颜色**；如果两个点颜色**一样**，证明联通，否则不连通；这种方法叫做并查集的：【Quick-Find算法】

1. 联通判断：Ｏ(1)
2. 合并操作：Ｏ(n)

> QUICK-FIND算法思考：
>
> 1. 联通判断非常快，可是合并操作非常慢
> 2. 本质上问题中只是需要知道一个点与哪些点颜色相同
> 3. 若干点的颜色可以通过简洁指向同一个节点
> 4. 合并操作时，实际上是将一棵树作为另一棵树的子树

#### **2.QUICK-UNION算法**

1. 联通判断：tree_height　树高　极端情况下O(n)
2. 合并操作：tree_height     树高　极端情况下O(n)

> QUICK_UNION算法思考：
>
> 1. 极端情况下会退化成一条链
> 2. 合并操作很快
> 3. 将节点数量多的接到少的树上面，导致退化
> 4. 将树高深的接到浅的上面，导致退化

- 找到集合的代表元素（根节点），将根节点进行合并，将ａ集合的根节点接在b集合的根节点下面
- QUICK-UNION算法改进：树高过深导致查找过于慢，**让节点数量较少的成为子树**,于是有了WEIGHT QUICK-UNION算法

**3.WEIGHT QUICK-UNION算法**

有效的防止树退化成一条链

1. 联通判断：$log(N)$
2. 合并操作：$log(N)$

问题最终优化：参考Quick-Find算法，做【路径压缩】当我们查找过一遍之后，０号节点就被挂在了三号节点之后

## 平衡二叉查找树（平衡二叉排序树）

树型数据结构，学习究竟是如何维护性质

二叉排序树的删除：

1. 删除叶子节点

2. 删除出度为１的节点

3. 删除出度为２的节点

   快速排序的本质思维模型就是二叉排序树（思考快排　二叉排序树的联系※）

> 森林中的树都是一般树，无法区分左右孩子，没有中序遍历

**重点是旋转调整**

为什么这样调整，调整的原理

**※==推倒过程==※**↓

### 1.AVL树(平衡二叉排序树)

- 性质：`|H(left) - H(right)| <= 1`
- 优点：任意两个子树的高度差不超过１，由于对每个节点的左右子树的树高做了限制，所以整棵树不会退化成一个链表

> 思考：

### 2.旋转操作

（是所有想要保持高效查找性质的树的必需操作）

1. AVL树左旋　确定左旋节点，会变成左子树，右孩子会变根节点
2. 右旋（操作与左旋对称）　

**失衡类型**

- 平衡树的调整一定是从底向上

#### 习题课

- leetcode 128

#### 判断一个东西存在不存在，维护一个集合有或者没有（查找），平衡二叉排序树　哈希表　最高效的是哈希表

#### 排序和查找是一类问题

面对查找的需求　哈希表　平衡二叉排序树能解决９０%的问题

并查集　哈希　

- leetode 130

先建立并查集，建立编号　将边界建立一圈ｏ用０进行编号　判断边界点是否跟0联通，不联通翻转成x　

将并查集当做工具去用　

计算机科学是以算法为中心，向周围延展开来的学科，学到的知识要向算法靠拢，

- leetcode  200

建立并查集，表示点，将相同的数字联通，看森林里有几棵树，

- leetcode 547 

联通性判断问题　裸并查集

- leetcode 684
- leetcode 685

分两种情况讨论：入度为２的点

没有入度为２的点，说明有环，枚举环上的边，看删掉之后是否影响联通性

用出度判断，所有出度不为０的点　都在环里

- 计蒜客　字符串旋转矩阵

末尾先写上，头部字符是接在末尾字符的后面的　**字典序之后**相同字母的顺序是不会变的（从上至下）　**重点是还原成原来给的字符串顺序**　