1.根据算法的时间复杂度，可以将排序算法分为复杂度为：Ｏ（nlogn）O(n) 或Ｏ(n^2)等时间复杂度的算法。比如：Ｏ(n)的基数排序(radix sort) Ｏ(nlogn)的归并排序Ｏ(n^2)的冒泡排序。

2.根据排序过程中元素是否完全保存在内存中，可以将算法分为内部排序(internal sort)和外部排序(external sort)。

内部排序：

**１．插入排序(insertion sort)**

插入排序每次插入的时间复杂度为 O(n)，一共执行 n−1 次，因此总体时间复杂度为(n^２)，在查找插入位置的过程可以使用折半查找算法将查找位置的复杂度优化到O(logn),但因为还需要Ｏ(n)的时间复杂度来在顺序表上执行移动操作，所以总体时间复杂度仍然为Ｏ(n^2)

将数组分成已排序区（在前）和待排序区　将已排序去后面一个元素向前插入到待排序区中，直到待排序区没有元素为止。

**２．冒泡排序(bubble sort)** O(n^2)

**每一轮将一个最大的或最小值冒泡的已排序区的头部**

排序方式：倒序排序（从小到大排序　第一轮选择最大的冒到最后一位）

讲数组分成已排序区（在后）和待排序区　从头到位扫描待排序区，若前面的元素比后面的大，则交换　每一轮都会将待排序区最大的放到已排序区的开头　直到待排序区没有元素为止

冒泡排序优化：如果某轮冒泡过程结束以后　在本轮冒泡中没有产生任何交换　就可以结束整个冒泡排序的过程

**３．归并排序(merge sort)**

归并排序一共要进行O(logn)层归并操作，每层归并操作的总时间复杂度为Ｏ(n),因此总体时间复杂度为Ｏ(nlogn) 

注意：为了实现归并排序，每次合并都需要开辟额外的空间来临时保存合并后的排序结果，总共需要开辟Ｎ个元素的空间，所以空间复杂度为O(n)

**大数排序基本都是外部排序**

**分治的最小自己定义，在工程中最小一般为16个，小于16个用插入排序**

将插入排序分治成1/2 时间复杂度会变为(n^2)/4 + n 

**４．选择排序(selection sort)**

已排序区 待排序区 每次从待排序区中选择一个最小值放到已排序区的尾部 与待排序区头交换

**５．快速排序(quick sort)**



3.对于一个排序算法，如果任意两个元素ａi 和ａj在排序前的线性表中满足条件i < j，且ai = aj,在排序后ａi仍然在aj之前，则称这个排序算法为稳定排序(stable sort)，否则称这个排序算法为不稳定排序(unstable sort)。

稳定排序：插入　冒泡　归并

不稳定排序：快速　选择 希尔排序(shell sort) 堆排序(heap sort)

